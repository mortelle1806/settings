set t_Co=256

" This is for WSL, see https://github.com/Microsoft/WSL/issues/1706
" Note: Commented because I use urxvt now and it prevents the code that
" modifies the cursor color to work fine.
"set term=screen-256color
"set t_ut=

" To disable a plugin, add it's bundle name to the following list
let g:pathogen_disabled = []

" Are we in vimdiff?
if &diff
    " Omnisharp seems to make vimdiff have an error message at startup
    " (related to a "/updatebuffer" commandline option)
    call add(g:pathogen_disabled, 'omnisharp-vim')
endif

" Pathogen
execute pathogen#infect()
syntax on
filetype plugin indent on

" Allows auto loading fzf.vim
" NOTE: Even if ~/.fzf is present already, make sure it is *installed* using
" included script 'install'.
set rtp+=~/.fzf

" No sounds when cursor blocked or whatever
set visualbell

" Makes vim behave like most editors:
" - The current buffer can be put to the background without writing to disk;
" - When a background buffer becomes current again, marks and undo-history are remembered.
" http://items.sjbach.com/319/configuring-vim-right
set hidden

set history=1000

syntax enable
set number
set relativenumber
set ruler " shows in status line where you are in the file

set incsearch
set ignorecase " often you want to ignore case when searching for text
set smartcase  " will turn on case-sensitivity only if the text to search contains uppercase characters, which is what you often want
set autoindent

" Necessary since switch from vim 7.4 to 8.1.
set backspace=indent,eol,start

" Shows selection size information in bottom line while in visual mode
set showcmd

set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab

" Will not cut words in the middle when wrap is on
set linebreak

"This makes sure a minimum number of lines is always visible above the cursor
set scrolloff=5

" Allows using the mouse to resize window splits!
set mouse=n

" Scroll the viewport (without moving the cursor) 3x faster
nnoremap <C-e> 3<C-e>
nnoremap <C-y> 3<C-y>

if !isdirectory($HOME . '/.vim/tmp')
    call mkdir($HOME . '/.vim/tmp', "p")
endif

" Tell vim where to put its backup files
" WARNING: Make sure directory exists or you can get weird errors (in NERDTree on opening, for instance)
set backupdir=~/.vim/tmp

" Tell vim where to put swap files
" WARNING: Make sure directory exists or you can get weird errors (in NERDTree on opening, for instance)
set dir=~/.vim/tmp

set background=dark

colorscheme PaperColor

" Background color approximation of what is in my Xresources in URxvt.background
" If you don't do this, by default vim will use all default colors of the
" terminal emulator, except for the background+foreground which will match
" with the chosen colorscheme.
hi Terminal ctermbg=234 ctermfg=grey

" <Leader>bg will switch color scheme between light and dark
" (restoring ModeMsg is important in this case, otherwise it's lost)
map <Leader>bg :let &background = ( &background == "dark"? "light" : "dark" )<CR>:hi ModeMsg ctermfg=white ctermbg=darkred<cr>

"<Leader> = \ by default

" source $MYVIMRC reloads the saved $MYVIMRC
:nmap <Leader>S :source $MYVIMRC

" opens $MYVIMRC for editing, or use :tabedit $MYVIMRC
:nmap <Leader>v :e $MYVIMRC

"-----------------------------------
"This unsets the "last search pattern" register by hitting return
"nnoremap <CR> :noh<CR><CR>

"set cursorline
"hi CursorLine term=NONE cterm=NONE ctermbg=none ctermfg=none

hi ModeMsg ctermfg=white ctermbg=darkred

" Change Color when entering Insert Mode
" autocmd InsertEnter * highlight  CursorLine ctermbg=darkred ctermfg=white

" Revert Color to default when leaving Insert Mode
" autocmd InsertLeave * highlight  CursorLine ctermbg=none ctermfg=none

" enable status line always
set laststatus=2

" redraw only when we need to.
set lazyredraw

set wildmenu            " visual autocomplete for command menu

" Indicate that the specified cscope commands must put their results in the quickfix window.
" The minus sign indicates to clear the quickfix window before putting the results.
set cscopequickfix=s-,c-,d-,i-,t-,e-,g-

let NERDTreeShowHidden=1
let NERDTreeMinimalUI=1 " Disables display of the 'Bookmarks' label and 'Press ? for help' text
let g:NERDTreeWinSize=60
let g:NERDTreeWinPos = "right"

" Quick save and exit
nnoremap <Leader><Leader> :xa<CR>

" Toggle NERDTree and switch to it
map <Leader>nt :NERDTreeToggle<CR>

" Make NERDTree open tree to current file
map <Leader>nf :NERDTreeFind<CR>

" Don't wrap by default after startup
set nowrap

if &diff
    " Toggle wrap in all windows (works in vimdiff)
    " Do not show new value in current window because it would make a prompt to
    " continue after the result is output
    nnoremap <Leader>ww :windo set wrap!<CR>
else
    " Toggle wrap in current windows and show new value in current window.
    nnoremap <Leader>ww :set wrap! wrap?<CR>
endif

" Toggle paste
nnoremap <Leader>p :set paste! paste?<CR>

" Toggle search results highlighting
nnoremap <Leader>hl :set hlsearch! hlsearch?<CR>

" Toggle showing whitespace characters
nnoremap <Leader>ws :set list! list?<CR>

" Show the most important whitespace characters
set listchars=tab:>-,trail:·,eol:$

" Go to previous error in quickfix window
" Go to next error in quickfix window
" NOTE: This overrides the ( and ) which are useful but I don't use so far.
nnoremap ( :cp<CR>
nnoremap ) :cn<CR>

" Use vim-bufkill buffer backward-forward commands because they successfully
" avoid that an open built-in terminal buffer gets used. In fact it seems that
" it successfully cycles only in buffers actually opened in the current
" window, which is exactly what I want.
nnoremap _ :BB<CR>
nnoremap + :BF<CR>

" Shortcut for Ack.vim. Ack with '!' does not jump automatically to first result,
" and in fact having Ack-vim jump automatically triggers a bug when in ide
" mode if you are currently focused on NERDTree (file will be open in this
" window instead of the code window). This does not happen with Ack!. 
nnoremap <Leader>a :Ack!<Space>
tnoremap <Leader>a <C-W><C-W>:Ack!<Space>

" Make Ack.vim use Ag if possible (much faster)
if executable('ag')
  let g:ackprg = 'ag --vimgrep'
endif

" https://stackoverflow.com/questions/657447/vim-clear-last-search-highlighting
" Double escape clears search pattern
nnoremap <silent> <Esc><Esc> :let @/=""<CR>

" Immediately highlight all occurrences of current word in buffer
let g:HiCursorWords_style='term=reverse cterm=reverse'
let g:HiCursorWords_delay=0

" Easy shortcut to switch terminal to Terminal-Normal mode
tnoremap <Leader>i <C-W>N

" Note the trailing space
inoremap <C-B> <3<Space> 

iabbrev coeur cœur
iabbrev oeil œil
iabbrev ps: P.-S.:
iabbrev ps2: P.-S.2:
iabbrev 3c <3 <3 <3... :)
iabbrev 4c <3 <3 <3 <3... :)
iabbrev 5c <3 <3 <3 <3 <3... :)
iabbrev 6c <3 <3 <3 <3 <3 <3... :)
iabbrev 7c <3 <3 <3 <3 <3 <3 <3... :)
iabbrev 8c <3 <3 <3 <3 <3 <3 <3 <3... :)
iabbrev 9c <3 <3 <3 <3 <3 <3 <3 <3 <3... :)
iabbrev 10c <3 <3 <3 <3 <3 <3 <3 <3 <3 <3... :)
iabbrev 11c <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3... :)
iabbrev 12c <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3... :)
iabbrev 13c <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3... :)
iabbrev 14c <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3... :)
iabbrev 15c <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3 <3... :)

" This is for CTRL+n autocompletion while in insert mode.
" The above command will change the 'completeopt' option so that Vim's popup menu doesn't select the first completion item, but rather just inserts the longest common text of all matches; and the menu will come up even if there's only one match. (The longest setting is responsible for the former effect and the menuone is responsible for the latter.) 
set completeopt=longest,menuone

" The following will make the cursor move by display lines when long lines are wrapping
" Source: http://vim.wikia.com/wiki/Move_cursor_by_display_lines_when_wrapping
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk

" Make - and + (in fact =) make browsing code with less RSI
noremap - 4gk
noremap = 4gj

" Quick save file (only if changed) and restore previous mode if any
nmap <Leader>s :update<CR>
vmap <Leader>s <Esc><Leader>sgv
imap <Leader>s <c-o><Leader>s

" Back tick as replacement for Esc. Tab is good too but as soon as you start
" programming, you regret it.
imap ` <Esc>
vmap ` <Esc>

" Since tilda is now taken in insert mode, provide a way to write a tilda in
" insert mode using C-V C-V
inoremap <C-V><C-V> <C-V>u0060

" Make shift-Tab decrease indent like in most editors
inoremap <S-Tab> <C-d>

" Reload current file
nnoremap <Leader>r :e<CR>

" Activate patience algorithm by default.
" Can switch on the fly to another algorithm with :EnhancedDiff <...>
" Enhances diff a lot in some cases.
" Try vimdiff in .vim/bundle/vim-enhanced-diff/test/4
" Result screenshot in https://github.com/chrisbra/vim-diff-enhanced
if &diff
    let &diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=patience")'
endif

" Set up cursor behaviour:
if &term =~ "xterm\\|rxvt"
    " use an cursor of a certain color in insert mode
    let &t_SI = "\<Esc>]12;red\x7"
    " use a another cursor color otherwise
    let &t_EI = "\<Esc>]12;gray\x7"
    silent !echo -ne "\033]12;gray\007"
    " reset cursor when vim exits
    autocmd VimLeave * silent !echo -ne "\033]12;gray\007"
endif

" Makes yanking and pasting use the X clipboard. Prepend it because their is a
" default value already (probably the exclude statement in the default value
" is the cause)
set clipboard^=unnamed

" Disable default clipboard behavior that makes visual mode copy to clipboard
" on each change of visual selection.
set clipboard-=autoselect

" This makes the buffers created for terminal use to be marked as 'unlisted'.
" This prevents :bp and :bn to cycle on these windows and get stuck on the
" shell prompt if the terminal is not in normal mode. Another example of
" unlisted buffer is the NERDTree buffer. Type !ls to see all buffers included
" unlisted ones. Source for this solution: https://github.com/jalvesaq/Nvim-R/issues/340
" NOTE: DEACTIVATED BECAUSE IT PREVENTS USING term_sendkeys()
"autocmd TerminalOpen * set nobuflisted

" Not vimdiff?
if &diff == 0
    let g:OmniSharp_server_path = '/mnt/f/tools/omnisharp.http-win-x64/OmniSharp.exe'
    let g:OmniSharp_translate_cygwin_wsl = 1

    " Timeout in seconds to wait for a response from the server
    let g:OmniSharp_timeout = 30

    let g:OmniSharp_selector_ui = 'fzf'

    augroup omnisharp_commands
        autocmd!

        " Automatic syntax check on events (TextChanged requires Vim 7.4)
        "autocmd BufEnter,TextChanged,InsertLeave *.cs SyntasticCheck

        " Show type information automatically when the cursor stops moving
        autocmd CursorHold *.cs call OmniSharp#TypeLookupWithoutDocumentation()

        " The following commands are contextual, based on the cursor position.
        autocmd FileType cs nnoremap <buffer> gd :OmniSharpGotoDefinition<CR>
        autocmd FileType cs nnoremap <buffer> <Leader>fi :OmniSharpFindImplementations<CR>
        autocmd FileType cs nnoremap <buffer> <Leader>fs :OmniSharpFindSymbol<CR>
        autocmd FileType cs nnoremap <buffer> <Leader>fu :OmniSharpFindUsages<CR>

        " Finds members in the current buffer
        autocmd FileType cs nnoremap <buffer> <Leader>fm :OmniSharpFindMembers<CR>

        autocmd FileType cs nnoremap <buffer> <Leader>fx :OmniSharpFixUsings<CR>
        autocmd FileType cs nnoremap <buffer> <Leader>tt :OmniSharpTypeLookup<CR>
        autocmd FileType cs nnoremap <buffer> <Leader>dc :OmniSharpDocumentation<CR>
        autocmd FileType cs nnoremap <buffer> <C-\> :OmniSharpSignatureHelp<CR>
        autocmd FileType cs inoremap <buffer> <C-\> <C-o>:OmniSharpSignatureHelp<CR>

        " Navigate up and down by method/property/field
        "autocmd FileType cs nnoremap <buffer> <C-k> :OmniSharpNavigateUp<CR>
        "autocmd FileType cs nnoremap <buffer> <C-j> :OmniSharpNavigateDown<CR>
    augroup END

    " Rename with dialog
    nnoremap <Leader>nm :OmniSharpRename<CR>
    "nnoremap <F2> :OmniSharpRename<CR>
    " Rename without dialog - with cursor on the symbol to rename: `:Rename newname`
    command! -nargs=1 Rename :call OmniSharp#RenameTo("<args>")

    nnoremap <Leader>cf :OmniSharpCodeFormat<CR>

    " Start the omnisharp server for the current solution
    "nnoremap <Leader>ss :OmniSharpStartServer<CR>
    "nnoremap <Leader>sp :OmniSharpStopServer<CR>

    " Add syntax highlighting for types and interfaces
    nnoremap <Leader>ht :OmniSharpHighlightTypes<CR>
endif
